{
  "top_code": "import Mathlib\nuniverse u v w u_1 u_2 u_3 u\u2081 u\u2082 u\u2083\nset_option maxHeartbeats 10000000\nset_option linter.unreachableTactic false\nopen Nat\n",
  "task": "lean_from_json_structured",
  "result": "success",
  "lean_code": "theorem divisible_by_six_imp_divisible_by_two : \u2200 (n : \u2115), 6 \u2223 n \u2192 2 \u2223 n :=\n    by\n    intro n a_7483115061731082443\n    have assert_1537035095498445343 : \u2203 (k : \u2115), n = 6 * k :=\n      by\n      trace\n        \"Automation Tactics first\\n  | simp?\\n  | hammer [] {aesopPremises := 0, autoPremises := 0} for goal: \u2203 k, n = 6 * k\"\n      exact a_7483115061731082443\n      trace\n        \"Finished Automation Tactics first\\n  | simp?\\n  | hammer [] {aesopPremises := 0, autoPremises := 0} for goal: \u2203 k, n = 6 * k\"\n    let \u27e8k, assert_10519291151578733484\u27e9 := assert_1537035095498445343\n    have assert_2577357155704612531 : 6 \u2223 n \u2192 \u2203 (k : \u2115), n = 6 * k \u2227 n = 2 * (3 * k) :=\n      by\n      trace\n        \"Automation Tactics first\\n  | simp?\\n  | hammer [] {aesopPremises := 0, autoPremises := 0} for goal: 6 \u2223 n \u2192 \u2203 k, n = 6 * k \u2227 n = 2 * (3 * k)\"\n      intro a\n      subst assert_10519291151578733484\n      simp_all only [mul_eq_mul_left_iff, OfNat.ofNat_ne_zero, or_false, exists_eq', dvd_mul_right, exists_eq_left']\n      sorry\n      trace\n        \"Finished Automation Tactics first\\n  | simp?\\n  | hammer [] {aesopPremises := 0, autoPremises := 0} for goal: 6 \u2223 n \u2192 \u2203 k, n = 6 * k \u2227 n = 2 * (3 * k)\"\n    have assert_17846023356657540758 : 6 \u2223 n \u2192 \u2203 (k : \u2115), n = 6 * k :=\n      by\n      trace\n        \"Automation Tactics first\\n  | simp?\\n  | hammer [] {aesopPremises := 0, autoPremises := 0} for goal: 6 \u2223 n \u2192 \u2203 k, n = 6 * k\"\n      intro a\n      subst assert_10519291151578733484\n      simp_all only [mul_eq_mul_left_iff, OfNat.ofNat_ne_zero, or_false, exists_eq', exists_eq_left', forall_const]\n      exact a\n      trace\n        \"Finished Automation Tactics first\\n  | simp?\\n  | hammer [] {aesopPremises := 0, autoPremises := 0} for goal: 6 \u2223 n \u2192 \u2203 k, n = 6 * k\"\n    have assert_13859010503934795551 : \u2203 (k : \u2115), n = 6 * k \u2192 2 \u2223 6 * k :=\n      by\n      trace\n        \"Automation Tactics first\\n  | simp?\\n  | hammer [] {aesopPremises := 0, autoPremises := 0} for goal: \u2203 k, n = 6 * k \u2192 2 \u2223 6 * k\"\n      subst assert_10519291151578733484\n      simp_all only [dvd_mul_right, mul_eq_mul_left_iff, OfNat.ofNat_ne_zero, or_false, exists_eq', exists_eq_left',\n        forall_const]\n      sorry\n      trace\n        \"Finished Automation Tactics first\\n  | simp?\\n  | hammer [] {aesopPremises := 0, autoPremises := 0} for goal: \u2203 k, n = 6 * k \u2192 2 \u2223 6 * k\"\n    let \u27e8k, assert_10109575230070458260\u27e9 := assert_13859010503934795551\n    have assert_10392182263119662666 : 6 \u2223 n \u2192 \u2203 (k : \u2115), n = 6 * k \u2192 2 \u2223 n :=\n      by\n      trace\n        \"Automation Tactics first\\n  | simp?\\n  | hammer [] {aesopPremises := 0, autoPremises := 0} for goal: 6 \u2223 n \u2192 \u2203 k, n = 6 * k \u2192 2 \u2223 n\"\n      intro a\n      subst assert_10519291151578733484\n      simp_all only [mul_eq_mul_left_iff, OfNat.ofNat_ne_zero, or_false, exists_eq', exists_eq_left', forall_const]\n      trace\n        \"Finished Automation Tactics first\\n  | simp?\\n  | hammer [] {aesopPremises := 0, autoPremises := 0} for goal: 6 \u2223 n \u2192 \u2203 k, n = 6 * k \u2192 2 \u2223 n\"\n    have : 6 \u2223 n \u2192 2 \u2223 n :=\n      by\n      trace\n        \"Automation Tactics first\\n  | simp?\\n  | hammer [] {aesopPremises := 0, autoPremises := 0} for goal: 6 \u2223 n \u2192 2 \u2223 n\"\n      intro a\n      subst assert_10519291151578733484\n      simp_all only [mul_eq_mul_left_iff, OfNat.ofNat_ne_zero, or_false, exists_eq', exists_eq_left', forall_const,\n        implies_true, dvd_mul_right]\n      trace\n        \"Finished Automation Tactics first\\n  | simp?\\n  | hammer [] {aesopPremises := 0, autoPremises := 0} for goal: 6 \u2223 n \u2192 2 \u2223 n\"\n    (expose_names; exact h a_7483115061731082443)",
  "json_structured": {
    "document": [
      {
        "type": "Theorem",
        "proof": {
          "type": "Proof",
          "proof_steps": [
            [
              {
                "variable_type": "natural number",
                "variable_name": "n",
                "type": "let_statement",
                "statement": "Let n be an arbitrary natural number."
              },
              {
                "variable_name": "k",
                "variable_kind": "natural number",
                "type": "some_statement",
                "statement": "There exists a natural number k such that n = 6 * k."
              },
              {
                "type": "assert_statement",
                "claim": "n = 2 * (3 * k)."
              },
              {
                "type": "assert_statement",
                "claim": "2 divides 2 * (3 * k)."
              },
              {
                "type": "assert_statement",
                "claim": "2 divides 6 * k."
              },
              {
                "type": "assert_statement",
                "claim": "2 divides n."
              },
              {
                "type": "conclude_statement",
                "claim": "If 6 divides n, then 2 divides n."
              }
            ]
          ],
          "claim_label": "thm:div6-2"
        },
        "label": "thm:div6-2",
        "header": "Theorem",
        "claim": "If a number n is divisible by 6, then it is divisible by 2."
      }
    ]
  },
  "greedy": false,
  "declarations": [
    "divisible_by_six_imp_divisible_by_two"
  ]
}